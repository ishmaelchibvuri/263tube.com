import { DynamoDBClient } from "@aws-sdk/client-dynamodb";
import {
  DynamoDBDocumentClient,
  PutCommand,
  QueryCommand,
  UpdateCommand,
  DeleteCommand,
  GetCommand,
} from "@aws-sdk/lib-dynamodb";

const client = new DynamoDBClient({});
const docClient = DynamoDBDocumentClient.from(client);
const TABLE_NAME = process.env.TABLE_NAME!;

export interface PaymentRecord {
  paymentId: string;
  userId: string;
  debtId: string;
  amount: number;
  paymentDate: string;
  paymentType?: 'minimum' | 'extra' | 'manual' | 'auto';
  paymentSource?: 'strategy_allocation' | 'manual_entry' | 'auto_minimum';
  appliedToFees: number;
  appliedToInterest: number;
  appliedToPrincipal: number;
  balanceBefore?: number;
  balanceAfter: number;
  notes?: string;
  isAutoGenerated?: boolean;
  createdAt: string;
  updatedAt?: string;
}

/**
 * Database helpers for payment tracking
 *
 * DynamoDB Access Patterns:
 * 1. Payment by ID: PK = USER#{userId}, SK = PAYMENT#{paymentDate}#{debtId}#{paymentId}
 * 2. All payments for user: PK = USER#{userId}, SK begins_with PAYMENT#
 * 3. Payments for debt (GSI3): GSI3PK = DEBT#{debtId}, GSI3SK = {paymentDate}
 */
export class PaymentDatabaseHelpers {
  /**
   * Log a payment
   */
  static async logPayment(payment: PaymentRecord): Promise<PaymentRecord> {
    try {
      const item = {
        PK: `USER#${payment.userId}`,
        SK: `PAYMENT#${payment.paymentDate}#${payment.debtId}#${payment.paymentId}`,
        GSI3PK: `DEBT#${payment.debtId}`,
        GSI3SK: payment.paymentDate,
        ...payment,
      };

      console.log("Saving payment to DynamoDB:", JSON.stringify(item, null, 2));

      const command = new PutCommand({
        TableName: TABLE_NAME,
        Item: item,
      });

      await docClient.send(command);
      console.log("✅ Payment logged successfully:", payment.paymentId);

      return payment;
    } catch (error) {
      console.error("Error logging payment to DynamoDB:", error);
      console.error("Payment data that failed:", JSON.stringify(payment, null, 2));

      // Preserve the original error message
      if (error instanceof Error) {
        throw new Error(`Failed to log payment: ${error.message}`);
      }
      throw error;
    }
  }

  /**
   * Get payment history for a debt
   */
  static async getDebtPaymentHistory(debtId: string): Promise<PaymentRecord[]> {
    try {
      const command = new QueryCommand({
        TableName: TABLE_NAME,
        IndexName: "GSI3",
        KeyConditionExpression: "GSI3PK = :pk",
        ExpressionAttributeValues: {
          ":pk": `DEBT#${debtId}`,
        },
        ScanIndexForward: false, // Most recent first
      });

      const response = await docClient.send(command);
      return (response.Items || []).map(item => this.itemToPayment(item));
    } catch (error) {
      console.error("Error getting payment history:", error);
      throw new Error("Failed to retrieve payment history");
    }
  }

  /**
   * Get all payments for a user
   */
  static async getUserPaymentHistory(userId: string): Promise<PaymentRecord[]> {
    try {
      const command = new QueryCommand({
        TableName: TABLE_NAME,
        KeyConditionExpression: "PK = :pk AND begins_with(SK, :sk)",
        ExpressionAttributeValues: {
          ":pk": `USER#${userId}`,
          ":sk": "PAYMENT#",
        },
        ScanIndexForward: false, // Most recent first
      });

      const response = await docClient.send(command);
      return (response.Items || []).map(item => this.itemToPayment(item));
    } catch (error) {
      console.error("Error getting user payment history:", error);
      throw new Error("Failed to retrieve payment history");
    }
  }

  /**
   * Get a specific payment by ID
   */
  static async getPayment(userId: string, debtId: string, paymentId: string, paymentDate: string): Promise<PaymentRecord | null> {
    try {
      const command = new GetCommand({
        TableName: TABLE_NAME,
        Key: {
          PK: `USER#${userId}`,
          SK: `PAYMENT#${paymentDate}#${debtId}#${paymentId}`,
        },
      });

      const response = await docClient.send(command);
      return response.Item ? this.itemToPayment(response.Item) : null;
    } catch (error) {
      console.error("Error getting payment:", error);
      throw new Error("Failed to retrieve payment");
    }
  }

  /**
   * Update a payment
   */
  static async updatePayment(
    userId: string,
    debtId: string,
    paymentId: string,
    paymentDate: string,
    updates: Partial<Pick<PaymentRecord, 'amount' | 'paymentDate' | 'notes' | 'paymentType' | 'paymentSource'>>
  ): Promise<PaymentRecord> {
    try {
      const updateExpressions: string[] = [];
      const expressionAttributeNames: Record<string, string> = {};
      const expressionAttributeValues: Record<string, any> = {};

      // Build dynamic update expression
      if (updates.amount !== undefined) {
        updateExpressions.push('#amount = :amount');
        expressionAttributeNames['#amount'] = 'amount';
        expressionAttributeValues[':amount'] = updates.amount;
      }

      if (updates.notes !== undefined) {
        updateExpressions.push('#notes = :notes');
        expressionAttributeNames['#notes'] = 'notes';
        expressionAttributeValues[':notes'] = updates.notes;
      }

      if (updates.paymentType !== undefined) {
        updateExpressions.push('#paymentType = :paymentType');
        expressionAttributeNames['#paymentType'] = 'paymentType';
        expressionAttributeValues[':paymentType'] = updates.paymentType;
      }

      if (updates.paymentSource !== undefined) {
        updateExpressions.push('#paymentSource = :paymentSource');
        expressionAttributeNames['#paymentSource'] = 'paymentSource';
        expressionAttributeValues[':paymentSource'] = updates.paymentSource;
      }

      // Always update updatedAt
      updateExpressions.push('#updatedAt = :updatedAt');
      expressionAttributeNames['#updatedAt'] = 'updatedAt';
      expressionAttributeValues[':updatedAt'] = new Date().toISOString();

      const command = new UpdateCommand({
        TableName: TABLE_NAME,
        Key: {
          PK: `USER#${userId}`,
          SK: `PAYMENT#${paymentDate}#${debtId}#${paymentId}`,
        },
        UpdateExpression: `SET ${updateExpressions.join(', ')}`,
        ExpressionAttributeNames: expressionAttributeNames,
        ExpressionAttributeValues: expressionAttributeValues,
        ReturnValues: 'ALL_NEW',
      });

      const response = await docClient.send(command);
      console.log("✅ Payment updated:", paymentId);

      return this.itemToPayment(response.Attributes!);
    } catch (error) {
      console.error("Error updating payment:", error);
      throw new Error("Failed to update payment");
    }
  }

  /**
   * Delete a payment
   */
  static async deletePayment(userId: string, debtId: string, paymentId: string, paymentDate: string): Promise<void> {
    try {
      const command = new DeleteCommand({
        TableName: TABLE_NAME,
        Key: {
          PK: `USER#${userId}`,
          SK: `PAYMENT#${paymentDate}#${debtId}#${paymentId}`,
        },
      });

      await docClient.send(command);
      console.log("✅ Payment deleted:", paymentId);
    } catch (error) {
      console.error("Error deleting payment:", error);
      throw new Error("Failed to delete payment");
    }
  }

  /**
   * Helper: Convert DynamoDB item to PaymentRecord object
   */
  private static itemToPayment(item: any): PaymentRecord {
    return {
      paymentId: item.paymentId,
      userId: item.userId,
      debtId: item.debtId,
      amount: item.amount,
      paymentDate: item.paymentDate,
      paymentType: item.paymentType,
      paymentSource: item.paymentSource,
      appliedToFees: item.appliedToFees || 0,
      appliedToInterest: item.appliedToInterest || 0,
      appliedToPrincipal: item.appliedToPrincipal || 0,
      balanceBefore: item.balanceBefore,
      balanceAfter: item.balanceAfter,
      notes: item.notes,
      isAutoGenerated: item.isAutoGenerated,
      createdAt: item.createdAt,
      updatedAt: item.updatedAt,
    };
  }
}
